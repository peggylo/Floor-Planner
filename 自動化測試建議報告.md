# Floor-Planner 自動化測試建議報告

**專案名稱：** Space M 座位安排工具 (Floor-Planner)
**報告日期：** 2026-02-18
**技術棧：** React 19 + TypeScript + Vite

---

## 目錄

1. [現況分析](#1-現況分析)
2. [測試策略建議](#2-測試策略建議)
3. [推薦測試框架](#3-推薦測試框架)
4. [測試安裝與設定](#4-測試安裝與設定)
5. [單元測試建議](#5-單元測試建議)
6. [元件測試建議](#6-元件測試建議)
7. [整合測試建議](#7-整合測試建議)
8. [端對端測試建議](#8-端對端測試建議)
9. [CI/CD 整合](#9-cicd-整合)
10. [測試覆蓋率目標](#10-測試覆蓋率目標)
11. [優先順序與實作路線圖](#11-優先順序與實作路線圖)

---

## 1. 現況分析

### 1.1 專案結構

```
src/
├── components/
│   ├── DraggableFurniture.tsx   # 可拖曳家具元件
│   └── Sidebar.tsx              # 側邊欄控制面板
├── App.tsx                      # 主應用程式（696 行）
├── types.ts                     # TypeScript 型別定義
└── main.tsx                     # 進入點
```

### 1.2 現況缺口

| 項目 | 現況 | 說明 |
|------|------|------|
| 測試框架 | ❌ 未設定 | `package.json` 中無測試相依套件 |
| 測試檔案 | ❌ 無 | 專案中無任何 `.test.ts` / `.spec.ts` 檔案 |
| 測試指令 | ❌ 未定義 | `scripts` 中無 `test` 指令 |
| ESLint | ✅ 已設定 | 已有基礎靜態分析 |
| TypeScript | ✅ 嚴格模式 | 已啟用 `strict` 模式 |
| CI/CD | ⚠️ 僅建置 | GitHub Actions 目前只做部署，未執行測試 |

### 1.3 核心業務邏輯識別

以下功能具有高測試價值，應優先覆蓋：

| 功能模組 | 相關檔案 | 複雜度 |
|----------|----------|--------|
| 家具數量限制邏輯 | `App.tsx:142-147`, `types.ts:30-81` | 中 |
| 多選與框選邏輯 | `App.tsx:233-337` | 高 |
| 批次拖曳同步 | `App.tsx:214-224` | 高 |
| 鍵盤快捷鍵 | `App.tsx:483-511` | 中 |
| 縮放邊界控制 | `App.tsx:149-150` | 低 |
| 旋轉角度計算 | `App.tsx:346-352` | 低 |
| 複製貼上偏移 | `App.tsx:361-381` | 中 |
| LocalStorage 序列化 | `App.tsx:30-67` | 中 |
| JSON 匯入驗證 | `App.tsx:113-130` | 中 |

---

## 2. 測試策略建議

採用**測試金字塔**架構，從下往上建立：

```
         /\
        /E2E\          ← 少量、高價值的端對端測試
       /------\
      /  整合   \       ← 中量、驗證元件互動
     /----------\
    /  單元測試  \      ← 大量、快速、聚焦業務邏輯
   /____________\
```

### 目標分佈

| 層次 | 比例 | 說明 |
|------|------|------|
| 單元測試 | 70% | 純函式、狀態邏輯、型別驗證 |
| 元件/整合測試 | 20% | React 元件渲染與互動 |
| E2E 測試 | 10% | 完整使用者流程 |

---

## 3. 推薦測試框架

### 3.1 主測試框架：Vitest

**選擇原因：**
- 與 Vite 原生整合，無需額外設定
- 比 Jest 更快（利用 Vite 的 ESM 支援）
- API 與 Jest 相容，學習曲線低
- 支援 TypeScript 原生

### 3.2 元件測試：React Testing Library

**選擇原因：**
- 以使用者行為為中心的測試方式
- 避免測試實作細節
- 與 Vitest 完整整合

### 3.3 E2E 測試：Playwright

**選擇原因：**
- 支援 Chromium、Firefox、WebKit
- 原生支援拖曳事件（對本專案至關重要）
- 比 Cypress 更快、更穩定
- 可測試鍵盤快捷鍵與複雜互動

---

## 4. 測試安裝與設定

### 4.1 安裝相依套件

```bash
# 單元測試 + 元件測試
npm install -D vitest @vitest/ui @vitest/coverage-v8
npm install -D @testing-library/react @testing-library/user-event @testing-library/jest-dom
npm install -D jsdom

# E2E 測試
npm install -D @playwright/test
npx playwright install
```

### 4.2 更新 `package.json` 的 scripts

```json
{
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:run": "vitest run",
    "test:coverage": "vitest run --coverage",
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui"
  }
}
```

### 4.3 Vitest 設定（`vite.config.ts`）

```typescript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  base: '/Floor-Planner/',
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'src/test/',
        '**/*.d.ts',
        'src/main.tsx',
      ],
    },
  },
});
```

### 4.4 測試環境設定（`src/test/setup.ts`）

```typescript
import '@testing-library/jest-dom';

// Mock localStorage
const localStorageMock = (() => {
  let store: Record<string, string> = {};
  return {
    getItem: (key: string) => store[key] ?? null,
    setItem: (key: string, value: string) => { store[key] = value; },
    removeItem: (key: string) => { delete store[key]; },
    clear: () => { store = {}; },
  };
})();
Object.defineProperty(window, 'localStorage', { value: localStorageMock });

// Mock URL.createObjectURL
global.URL.createObjectURL = vi.fn(() => 'mock-url');
global.URL.revokeObjectURL = vi.fn();
```

### 4.5 Playwright 設定（`playwright.config.ts`）

```typescript
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './e2e',
  fullyParallel: true,
  retries: process.env.CI ? 2 : 0,
  use: {
    baseURL: 'http://localhost:5173',
    trace: 'on-first-retry',
  },
  projects: [
    { name: 'chromium', use: { ...devices['Desktop Chrome'] } },
    { name: 'firefox', use: { ...devices['Desktop Firefox'] } },
  ],
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:5173',
    reuseExistingServer: !process.env.CI,
  },
});
```

---

## 5. 單元測試建議

### 5.1 `types.ts` — 型別與常數驗證

**測試檔案：** `src/test/types.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import { ITEM_DEFS } from '../types';

describe('ITEM_DEFS 常數', () => {
  it('應包含所有預期的家具類型', () => {
    const expectedTypes = ['ibm', 'ibm_spare', 'chair_white', 'chair_brown', 'stool'];
    expectedTypes.forEach(type => {
      expect(ITEM_DEFS).toHaveProperty(type);
    });
  });

  it('每個家具定義應具備必要欄位', () => {
    Object.values(ITEM_DEFS).forEach(def => {
      expect(def).toHaveProperty('name');
      expect(def).toHaveProperty('width');
      expect(def).toHaveProperty('height');
      expect(def).toHaveProperty('color');
      expect(def).toHaveProperty('shape');
      expect(def.maxCount).toBeGreaterThan(0);
    });
  });

  it('IBM桌最大數量應為 24', () => {
    expect(ITEM_DEFS.ibm.maxCount).toBe(24);
  });

  it('白色椅子最大數量應為 106', () => {
    expect(ITEM_DEFS.chair_white.maxCount).toBe(106);
  });

  it('家具尺寸應為正數', () => {
    Object.values(ITEM_DEFS).forEach(def => {
      expect(def.width).toBeGreaterThan(0);
      expect(def.height).toBeGreaterThan(0);
    });
  });
});
```

### 5.2 業務邏輯純函式測試

建議將以下邏輯從 `App.tsx` 中抽取為純函式以利測試：

**建議抽取：** `src/utils/layoutUtils.ts`

```typescript
// 計算各類型家具使用數量
export function calculateCounts(items: PlacedItem[]): Record<ItemType, number>;

// 驗證 JSON 匯入格式
export function validateImportData(data: unknown): data is { items: PlacedItem[] };

// 計算縮放後座標
export function toScaledCoords(x: number, y: number, scale: number): { x: number; y: number };

// 計算選取框內的物件
export function getItemsInSelectionBox(
  items: PlacedItem[],
  box: SelectionBox,
  scale: number,
  containerOffset: { x: number; y: number }
): PlacedItem[];
```

**對應測試：** `src/test/layoutUtils.test.ts`

```typescript
describe('calculateCounts', () => {
  it('應正確計算各類型數量', () => {
    const items: PlacedItem[] = [
      { id: '1', type: 'ibm', x: 0, y: 0, rotation: 0 },
      { id: '2', type: 'ibm', x: 10, y: 0, rotation: 0 },
      { id: '3', type: 'chair_white', x: 20, y: 0, rotation: 0 },
    ];
    const counts = calculateCounts(items);
    expect(counts.ibm).toBe(2);
    expect(counts.chair_white).toBe(1);
  });

  it('text 類型不應列入計數', () => {
    const items: PlacedItem[] = [
      { id: '1', type: 'text', x: 0, y: 0, rotation: 0, text: '標記' },
    ];
    const counts = calculateCounts(items);
    expect(counts.text).toBeUndefined();
  });

  it('空陣列應回傳空物件', () => {
    expect(calculateCounts([])).toEqual({});
  });
});

describe('validateImportData', () => {
  it('有效資料應回傳 true', () => {
    const data = { items: [{ id: '1', type: 'ibm', x: 0, y: 0, rotation: 0 }] };
    expect(validateImportData(data)).toBe(true);
  });

  it('缺少 items 欄位應回傳 false', () => {
    expect(validateImportData({ name: 'test' })).toBe(false);
  });

  it('items 非陣列應回傳 false', () => {
    expect(validateImportData({ items: 'not-array' })).toBe(false);
  });
});
```

### 5.3 縮放邏輯測試

```typescript
describe('縮放控制', () => {
  it('放大不應超過最大值 3.0', () => {
    const newScale = Math.min(3.0 + 0.1, 3);
    expect(newScale).toBe(3);
  });

  it('縮小不應低於最小值 0.2', () => {
    const newScale = Math.max(0.2 - 0.1, 0.2);
    expect(newScale).toBe(0.2);
  });
});
```

### 5.4 旋轉邏輯測試

```typescript
describe('旋轉計算', () => {
  it('每次旋轉應增加 45 度', () => {
    expect((0 + 45) % 360).toBe(45);
    expect((315 + 45) % 360).toBe(0);  // 360 度歸零
    expect((270 + 45) % 360).toBe(315);
  });

  it('多次旋轉後應在 0-359 度範圍內', () => {
    let rotation = 0;
    for (let i = 0; i < 20; i++) {
      rotation = (rotation + 45) % 360;
      expect(rotation).toBeGreaterThanOrEqual(0);
      expect(rotation).toBeLessThan(360);
    }
  });
});
```

---

## 6. 元件測試建議

### 6.1 `Sidebar` 元件測試

**測試檔案：** `src/test/Sidebar.test.tsx`

```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { Sidebar } from '../components/Sidebar';

const defaultProps = {
  counts: {},
  onAdd: vi.fn(),
  savedLayouts: [],
  currentLayoutName: '',
  onSaveLayout: vi.fn(),
  onLoadLayout: vi.fn(),
  onDeleteLayout: vi.fn(),
  onExportJSON: vi.fn(),
  onImportJSON: vi.fn(),
  onClearAll: vi.fn(),
};

describe('Sidebar 元件', () => {
  it('應渲染所有家具類型按鈕', () => {
    render(<Sidebar {...defaultProps} />);
    expect(screen.getByText('IBM桌')).toBeInTheDocument();
    expect(screen.getByText('電資學院桌')).toBeInTheDocument();
    expect(screen.getByText('白色椅子')).toBeInTheDocument();
    expect(screen.getByText('咖啡色椅子')).toBeInTheDocument();
    expect(screen.getByText('高腳椅')).toBeInTheDocument();
  });

  it('點擊新增按鈕應呼叫 onAdd', async () => {
    const onAdd = vi.fn();
    render(<Sidebar {...defaultProps} onAdd={onAdd} />);
    await userEvent.click(screen.getAllByText('新增')[0]);
    expect(onAdd).toHaveBeenCalledOnce();
  });

  it('當 IBM桌數量達上限時，新增按鈕應停用', () => {
    render(<Sidebar {...defaultProps} counts={{ ibm: 24 }} />);
    // 驗證 ibm 的新增按鈕已停用
    const ibmSection = screen.getByText('IBM桌').closest('[data-testid="furniture-panel"]');
    const addButton = ibmSection?.querySelector('button');
    expect(addButton).toBeDisabled();
  });

  it('儲存配置應呼叫 onSaveLayout 並傳入輸入的名稱', async () => {
    const onSaveLayout = vi.fn();
    render(<Sidebar {...defaultProps} onSaveLayout={onSaveLayout} />);
    const input = screen.getByPlaceholderText('配置名稱');
    await userEvent.type(input, '測試配置');
    await userEvent.click(screen.getByText('儲存'));
    expect(onSaveLayout).toHaveBeenCalledWith('測試配置');
  });

  it('已儲存配置清單應顯示各配置名稱', () => {
    const layouts = [
      { id: '1', name: '配置A', items: [], savedAt: Date.now() },
      { id: '2', name: '配置B', items: [], savedAt: Date.now() },
    ];
    render(<Sidebar {...defaultProps} savedLayouts={layouts} />);
    expect(screen.getByText('配置A')).toBeInTheDocument();
    expect(screen.getByText('配置B')).toBeInTheDocument();
  });

  it('點擊清除全部應呼叫 onClearAll', async () => {
    const onClearAll = vi.fn();
    render(<Sidebar {...defaultProps} onClearAll={onClearAll} />);
    await userEvent.click(screen.getByText('清除全部'));
    expect(onClearAll).toHaveBeenCalledOnce();
  });
});
```

### 6.2 `DraggableFurniture` 元件測試

**測試檔案：** `src/test/DraggableFurniture.test.tsx`

```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { DraggableFurniture } from '../components/DraggableFurniture';
import type { PlacedItem } from '../types';

const createItem = (overrides: Partial<PlacedItem> = {}): PlacedItem => ({
  id: 'test-id',
  type: 'ibm',
  x: 100,
  y: 100,
  rotation: 0,
  ...overrides,
});

describe('DraggableFurniture 元件', () => {
  it('應渲染家具元件', () => {
    render(
      <DraggableFurniture
        item={createItem()}
        isSelected={false}
        scale={1}
        onSelect={vi.fn()}
        onUpdatePosition={vi.fn()}
        onDrag={vi.fn()}
      />
    );
    // 家具元素應存在
    expect(document.querySelector('[data-testid="furniture-item"]')).toBeInTheDocument();
  });

  it('被選取時應顯示選取樣式', () => {
    render(
      <DraggableFurniture
        item={createItem()}
        isSelected={true}
        scale={1}
        onSelect={vi.fn()}
        onUpdatePosition={vi.fn()}
        onDrag={vi.fn()}
      />
    );
    const el = document.querySelector('[data-testid="furniture-item"]');
    expect(el).toHaveStyle({ boxShadow: expect.stringContaining('3b82f6') });
  });

  it('文字類型：雙擊應進入編輯模式', async () => {
    const item = createItem({ type: 'text', text: '初始文字' });
    render(
      <DraggableFurniture
        item={item}
        isSelected={false}
        scale={1}
        onSelect={vi.fn()}
        onUpdatePosition={vi.fn()}
        onDrag={vi.fn()}
        onUpdateText={vi.fn()}
      />
    );
    const textEl = screen.getByText('初始文字');
    await userEvent.dblClick(textEl);
    expect(screen.getByRole('textbox')).toBeInTheDocument();
  });

  it('文字類型：按下 Enter 應提交文字並結束編輯', async () => {
    const onUpdateText = vi.fn();
    const item = createItem({ type: 'text', text: '初始文字' });
    render(
      <DraggableFurniture
        item={item}
        isSelected={false}
        scale={1}
        onSelect={vi.fn()}
        onUpdatePosition={vi.fn()}
        onDrag={vi.fn()}
        onUpdateText={onUpdateText}
      />
    );
    await userEvent.dblClick(screen.getByText('初始文字'));
    const textarea = screen.getByRole('textbox');
    await userEvent.clear(textarea);
    await userEvent.type(textarea, '新文字{Enter}');
    expect(onUpdateText).toHaveBeenCalledWith('新文字');
  });
});
```

### 6.3 `App` 元件整合測試

**測試檔案：** `src/test/App.test.tsx`

```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import App from '../App';

describe('App — 鍵盤快捷鍵', () => {
  beforeEach(() => {
    localStorage.clear();
  });

  it('Delete 鍵應刪除已選取的物件', async () => {
    render(<App />);
    // 新增一個物件
    await userEvent.click(screen.getAllByText('新增')[0]);
    // 驗證有物件存在...
    fireEvent.keyDown(window, { key: 'Delete' });
    // 驗證物件已刪除
  });

  it('R 鍵應旋轉已選取的物件', async () => {
    render(<App />);
    await userEvent.click(screen.getAllByText('新增')[0]);
    fireEvent.keyDown(window, { key: 'r' });
    // 驗證旋轉角度改變
  });

  it('在 input 欄位中按鍵不應觸發快捷鍵', async () => {
    const onDeleteMock = vi.fn();
    render(<App />);
    const input = screen.getByPlaceholderText('配置名稱');
    input.focus();
    fireEvent.keyDown(input, { key: 'Delete' });
    // 快捷鍵不應被觸發
  });
});

describe('App — LocalStorage', () => {
  it('應從 localStorage 載入已儲存的配置', () => {
    const savedData = {
      items: [{ id: '1', type: 'ibm', x: 100, y: 100, rotation: 0 }],
      name: '測試配置',
    };
    localStorage.setItem('space-m-current', JSON.stringify(savedData));
    render(<App />);
    // 驗證已載入的項目顯示在畫布上
  });

  it('狀態變更時應自動儲存至 localStorage', async () => {
    render(<App />);
    await userEvent.click(screen.getAllByText('新增')[0]);
    const stored = JSON.parse(localStorage.getItem('space-m-current') || '{}');
    expect(stored.items).toHaveLength(1);
  });
});

describe('App — 縮放', () => {
  it('點擊放大按鈕應增加縮放比例', async () => {
    render(<App />);
    await userEvent.click(screen.getByTitle('Zoom In'));
    // 驗證縮放比例增加（需透過 data-testid 或 aria 屬性驗證）
  });

  it('縮放比例不應超過 3.0', async () => {
    render(<App />);
    const zoomIn = screen.getByTitle('Zoom In');
    for (let i = 0; i < 30; i++) {
      await userEvent.click(zoomIn);
    }
    // 驗證縮放值被限制在 3.0
  });
});
```

---

## 7. 整合測試建議

### 7.1 LocalStorage 持久化整合測試

```typescript
describe('配置持久化', () => {
  it('完整流程：新增 → 儲存 → 重載 → 驗證', async () => {
    const { unmount } = render(<App />);
    // 1. 新增物件
    await userEvent.click(screen.getAllByText('新增')[0]);
    // 2. 儲存至命名配置
    await userEvent.type(screen.getByPlaceholderText('配置名稱'), '整合測試配置');
    await userEvent.click(screen.getByText('儲存'));
    // 3. 卸載並重新掛載元件（模擬重新整理）
    unmount();
    render(<App />);
    // 4. 驗證配置已保留
    expect(screen.getByText('整合測試配置')).toBeInTheDocument();
  });
});
```

### 7.2 JSON 匯入/匯出整合測試

```typescript
describe('JSON 匯入匯出', () => {
  it('匯出的 JSON 應可被正確匯入', async () => {
    render(<App />);
    // 建立測試資料
    await userEvent.click(screen.getAllByText('新增')[0]);

    // 模擬 JSON 匯入
    const validJSON = JSON.stringify({
      name: '匯入測試',
      items: [{ id: 'abc', type: 'ibm', x: 50, y: 50, rotation: 0 }],
    });
    const file = new File([validJSON], 'test.json', { type: 'application/json' });
    const input = document.querySelector('input[type="file"]') as HTMLInputElement;
    await userEvent.upload(input, file);

    // 驗證匯入成功
    expect(screen.getByText('匯入測試')).toBeInTheDocument();
  });

  it('無效 JSON 匯入應顯示錯誤提示', async () => {
    const alertMock = vi.spyOn(window, 'alert').mockImplementation(() => {});
    render(<App />);

    const invalidFile = new File(['{ invalid json }'], 'bad.json', { type: 'application/json' });
    const input = document.querySelector('input[type="file"]') as HTMLInputElement;
    await userEvent.upload(input, invalidFile);

    expect(alertMock).toHaveBeenCalledWith(expect.stringContaining('無法讀取'));
    alertMock.mockRestore();
  });
});
```

---

## 8. 端對端測試建議

### 8.1 核心使用流程 E2E 測試

**測試檔案：** `e2e/floor-planner.spec.ts`

```typescript
import { test, expect } from '@playwright/test';

test.describe('Floor Planner — 基本操作', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
    // 清除 localStorage 確保乾淨環境
    await page.evaluate(() => localStorage.clear());
    await page.reload();
  });

  test('應成功載入應用程式並顯示側邊欄', async ({ page }) => {
    await expect(page.getByText('IBM桌')).toBeVisible();
    await expect(page.getByText('白色椅子')).toBeVisible();
    await expect(page.locator('.workspace')).toBeVisible();
  });

  test('新增 IBM 桌至畫布', async ({ page }) => {
    await page.getByRole('button', { name: '新增' }).first().click();
    // 驗證家具已出現在畫布上
    await expect(page.locator('[data-testid="furniture-item"]')).toHaveCount(1);
  });

  test('拖曳家具至新位置', async ({ page }) => {
    await page.getByRole('button', { name: '新增' }).first().click();
    const furniture = page.locator('[data-testid="furniture-item"]').first();

    const box = await furniture.boundingBox();
    if (!box) throw new Error('找不到家具元素');

    await page.mouse.move(box.x + box.width / 2, box.y + box.height / 2);
    await page.mouse.down();
    await page.mouse.move(box.x + 200, box.y + 100);
    await page.mouse.up();

    const newBox = await furniture.boundingBox();
    expect(newBox?.x).not.toBe(box.x);
  });

  test('選取後按 Delete 鍵應刪除家具', async ({ page }) => {
    await page.getByRole('button', { name: '新增' }).first().click();
    await page.locator('[data-testid="furniture-item"]').first().click();
    await page.keyboard.press('Delete');
    await expect(page.locator('[data-testid="furniture-item"]')).toHaveCount(0);
  });

  test('按 R 鍵應旋轉已選取的家具', async ({ page }) => {
    await page.getByRole('button', { name: '新增' }).first().click();
    const furniture = page.locator('[data-testid="furniture-item"]').first();
    await furniture.click();

    // 記錄旋轉前的樣式
    const beforeStyle = await furniture.getAttribute('style');
    await page.keyboard.press('r');
    const afterStyle = await furniture.getAttribute('style');

    expect(afterStyle).not.toBe(beforeStyle);
    expect(afterStyle).toContain('rotate(45deg)');
  });
});

test.describe('Floor Planner — 多選操作', () => {
  test('框選應選取範圍內的所有物件', async ({ page }) => {
    await page.goto('/');
    // 新增多個物件
    for (let i = 0; i < 3; i++) {
      await page.getByRole('button', { name: '新增' }).first().click();
    }

    // 框選操作
    const workspace = page.locator('.workspace');
    await workspace.dragTo(workspace, {
      sourcePosition: { x: 0, y: 0 },
      targetPosition: { x: 800, y: 600 },
    });

    // 驗證多選狀態
    const selectedItems = page.locator('[data-testid="furniture-item"][data-selected="true"]');
    await expect(selectedItems).toHaveCount(3);
  });

  test('Ctrl+C / Ctrl+V 複製貼上', async ({ page }) => {
    await page.goto('/');
    await page.getByRole('button', { name: '新增' }).first().click();
    await page.locator('[data-testid="furniture-item"]').first().click();

    await page.keyboard.press('Control+c');
    await page.keyboard.press('Control+v');

    await expect(page.locator('[data-testid="furniture-item"]')).toHaveCount(2);
  });

  test('Ctrl+D 快速複製', async ({ page }) => {
    await page.goto('/');
    await page.getByRole('button', { name: '新增' }).first().click();
    await page.locator('[data-testid="furniture-item"]').first().click();

    await page.keyboard.press('Control+d');

    await expect(page.locator('[data-testid="furniture-item"]')).toHaveCount(2);
  });
});

test.describe('Floor Planner — 縮放功能', () => {
  test('放大按鈕應增加縮放比例', async ({ page }) => {
    await page.goto('/');
    await page.getByTitle('Zoom In').click();
    // 驗證容器 transform scale 值已增加
    const container = page.locator('[ref="containerRef"]');
    const style = await container.getAttribute('style');
    expect(style).toContain('scale(1.1)');
  });

  test('縮放比例應不超過 3.0', async ({ page }) => {
    await page.goto('/');
    for (let i = 0; i < 35; i++) {
      await page.getByTitle('Zoom In').click();
    }
    const container = page.locator('.floor-plan-container');
    const style = await container.getAttribute('style');
    expect(style).toContain('scale(3)');
    expect(style).not.toContain('scale(3.1)');
  });
});

test.describe('Floor Planner — 配置管理', () => {
  test('完整配置儲存與載入流程', async ({ page }) => {
    await page.goto('/');

    // 新增物件
    await page.getByRole('button', { name: '新增' }).first().click();

    // 儲存配置
    await page.getByPlaceholder('配置名稱').fill('E2E 測試配置');
    await page.getByRole('button', { name: '儲存' }).click();

    // 清除畫布
    await page.getByText('清除全部').click();
    await page.getByRole('button', { name: '確定' }).click(); // confirm dialog

    // 載入配置
    await page.getByText('E2E 測試配置').click();

    // 驗證物件已還原
    await expect(page.locator('[data-testid="furniture-item"]')).toHaveCount(1);
  });
});
```

---

## 9. CI/CD 整合

### 9.1 更新 GitHub Actions Workflow

**更新檔案：** `.github/workflows/deploy.yml`

```yaml
name: CI/CD Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    name: 執行測試
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: 設定 Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: 安裝相依套件
        run: npm ci

      - name: 執行 ESLint
        run: npm run lint

      - name: 執行單元與元件測試
        run: npm run test:run

      - name: 產生測試覆蓋率報告
        run: npm run test:coverage

      - name: 上傳覆蓋率報告
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage/

      - name: 安裝 Playwright 瀏覽器
        run: npx playwright install --with-deps chromium

      - name: 執行 E2E 測試
        run: npm run test:e2e

      - name: 上傳 E2E 測試報告
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: playwright-report
          path: playwright-report/

  deploy:
    name: 部署至 GitHub Pages
    needs: test  # 測試通過後才部署
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    # ... 原有部署步驟
```

---

## 10. 測試覆蓋率目標

| 模組 | 目標覆蓋率 | 說明 |
|------|-----------|------|
| `types.ts` | 100% | 常數與型別定義，易於測試 |
| `utils/layoutUtils.ts` (建議新增) | 90%+ | 純函式業務邏輯 |
| `components/Sidebar.tsx` | 80%+ | UI 邏輯與使用者互動 |
| `components/DraggableFurniture.tsx` | 75%+ | 拖曳與文字編輯邏輯 |
| `App.tsx` | 70%+ | 整體整合邏輯 |
| **全專案平均** | **≥ 75%** | 整體目標 |

---

## 11. 優先順序與實作路線圖

### 第一階段：基礎建設（最優先）

- [ ] 安裝 Vitest + Testing Library
- [ ] 設定 `vite.config.ts` 的測試環境
- [ ] 建立 `src/test/setup.ts` 與 mock
- [ ] 在 `package.json` 加入測試指令

### 第二階段：核心邏輯測試

- [ ] `types.ts` 常數與型別測試
- [ ] 建議重構：將業務邏輯抽取至 `src/utils/layoutUtils.ts`
- [ ] 縮放、旋轉邏輯單元測試
- [ ] 數量計算邏輯單元測試
- [ ] JSON 匯入驗證邏輯測試

### 第三階段：元件測試

- [ ] `Sidebar` 元件完整測試
- [ ] `DraggableFurniture` 元件測試（含文字編輯）
- [ ] `App` 鍵盤快捷鍵測試
- [ ] `App` LocalStorage 持久化測試

### 第四階段：E2E 測試

- [ ] 安裝 Playwright
- [ ] 基本操作流程（新增、移動、刪除）
- [ ] 多選與批次操作流程
- [ ] 配置儲存/載入流程
- [ ] 縮放功能測試

### 第五階段：CI/CD 整合

- [ ] 更新 GitHub Actions workflow 加入測試步驟
- [ ] 設定測試失敗時阻止部署
- [ ] 設定覆蓋率門檻（建議 ≥ 75%）
- [ ] 加入 PR 覆蓋率差異報告

---

## 附錄：建議的測試目錄結構

```
Floor-Planner/
├── src/
│   ├── test/
│   │   ├── setup.ts              # 測試環境設定
│   │   ├── types.test.ts         # 型別常數測試
│   │   ├── App.test.tsx          # 主應用測試
│   │   ├── Sidebar.test.tsx      # 側邊欄元件測試
│   │   └── DraggableFurniture.test.tsx
│   └── utils/
│       ├── layoutUtils.ts        # 建議抽取的業務邏輯
│       └── layoutUtils.test.ts
├── e2e/
│   └── floor-planner.spec.ts     # Playwright E2E 測試
├── playwright.config.ts
└── vite.config.ts                # 加入 test 設定
```

---

*本報告由 Claude Code 自動分析 Floor-Planner 專案原始碼後產生。*
*建議依照實際開發進度與資源，彈性調整各階段的實作優先順序。*
